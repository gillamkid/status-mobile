const process = require('process');
const babel = require('@babel/core');
const plugin = require('./node_modules/react-native-reanimated/plugin');


function transformString(inputString) {
  return babel.transformSync(inputString, {
    filename: '/dev/null',
    compact: false,
    presets: ['@babel/preset-es2015'],
  }).code;
}

// process.stdin.setEncoding('utf8');
// let input = '';
// process.stdin.on('data', (chunk) => {
//   input += chunk;
// });
//
// process.stdin.on('end', () => {
//   const result = transformString(input);
//   process.stdout.write(result);
// });

console.log(transformString
(
    "\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// lib/utils.js\nvar require_utils = __commonJS({\n  \"lib/utils.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.isRelease = void 0;\n    function isRelease() {\n      var _a, _b;\n      const pattern = /(prod|release|stag[ei])/i;\n      return !!(((_a = process.env.BABEL_ENV) === null || _a === void 0 ? void 0 : _a.match(pattern)) || ((_b = process.env.NODE_ENV) === null || _b === void 0 ? void 0 : _b.match(pattern)));\n    }\n    exports2.isRelease = isRelease;\n  }\n});\n\n// lib/buildWorkletString.js\nvar require_buildWorkletString = __commonJS({\n  \"lib/buildWorkletString.js\"(exports2) {\n    \"use strict\";\n    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {\n      if (k2 === void 0)\n        k2 = k;\n      var desc = Object.getOwnPropertyDescriptor(m, k);\n      if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = { enumerable: true, get: function() {\n          return m[k];\n        } };\n      }\n      Object.defineProperty(o, k2, desc);\n    } : function(o, m, k, k2) {\n      if (k2 === void 0)\n        k2 = k;\n      o[k2] = m[k];\n    });\n    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {\n      Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n    } : function(o, v) {\n      o[\"default\"] = v;\n    });\n    var __importStar = exports2 && exports2.__importStar || function(mod) {\n      if (mod && mod.__esModule)\n        return mod;\n      var result = {};\n      if (mod != null) {\n        for (var k in mod)\n          if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k))\n            __createBinding(result, mod, k);\n      }\n      __setModuleDefault(result, mod);\n      return result;\n    };\n    var __importDefault = exports2 && exports2.__importDefault || function(mod) {\n      return mod && mod.__esModule ? mod : { \"default\": mod };\n    };\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.buildWorkletString = void 0;\n    var core_1 = require(\"@babel/core\");\n    var generator_1 = __importDefault(require(\"@babel/generator\"));\n    var types_1 = require(\"@babel/types\");\n    var assert_1 = require(\"assert\");\n    var convertSourceMap = __importStar(require(\"convert-source-map\"));\n    var fs = __importStar(require(\"fs\"));\n    var utils_1 = require_utils();\n    var MOCK_SOURCE_MAP = \"mock source map\";\n    function buildWorkletString(fun, closureVariables, name, inputMap) {\n      const draftExpression = fun.program.body.find((obj) => (0, types_1.isFunctionDeclaration)(obj)) || fun.program.body.find((obj) => (0, types_1.isExpressionStatement)(obj)) || void 0;\n      (0, assert_1.strict)(draftExpression, \"[Reanimated] `draftExpression` is undefined.\");\n      const expression = (0, types_1.isFunctionDeclaration)(draftExpression) ? draftExpression : draftExpression.expression;\n      (0, assert_1.strict)(\"params\" in expression, \"'params' property is undefined in 'expression'\");\n      (0, assert_1.strict)((0, types_1.isBlockStatement)(expression.body), \"[Reanimated] `expression.body` is not a `BlockStatement`\");\n      const workletFunction = (0, types_1.functionExpression)((0, types_1.identifier)(name), expression.params, expression.body);\n      const code = (0, generator_1.default)(workletFunction).code;\n      (0, assert_1.strict)(inputMap, \"[Reanimated] `inputMap` is undefined.\");\n      const includeSourceMap = !(0, utils_1.isRelease)();\n      if (includeSourceMap) {\n        inputMap.sourcesContent = [];\n        for (const sourceFile of inputMap.sources) {\n          inputMap.sourcesContent.push(fs.readFileSync(sourceFile).toString(\"utf-8\"));\n        }\n      }\n      const transformed = (0, core_1.transformSync)(code, {\n        plugins: [prependClosureVariablesIfNecessary(closureVariables)],\n        compact: true,\n        sourceMaps: includeSourceMap,\n        inputSourceMap: inputMap,\n        ast: false,\n        babelrc: false,\n        configFile: false,\n        comments: false\n      });\n      (0, assert_1.strict)(transformed, \"[Reanimated] `transformed` is null.\");\n      let sourceMap;\n      if (includeSourceMap) {\n        if (shouldMockSourceMap()) {\n          sourceMap = MOCK_SOURCE_MAP;\n        } else {\n          sourceMap = convertSourceMap.fromObject(transformed.map).toObject();\n          delete sourceMap.sourcesContent;\n        }\n      }\n      return [transformed.code, JSON.stringify(sourceMap)];\n    }\n    exports2.buildWorkletString = buildWorkletString;\n    function shouldMockSourceMap() {\n      return process.env.REANIMATED_JEST_SHOULD_MOCK_SOURCE_MAP === \"1\";\n    }\n    function prependClosure(path, closureVariables, closureDeclaration) {\n      if (closureVariables.length === 0 || !(0, types_1.isProgram)(path.parent)) {\n        return;\n      }\n      if (!(0, types_1.isExpression)(path.node.body)) {\n        path.node.body.body.unshift(closureDeclaration);\n      }\n    }\n    function prependRecursiveDeclaration(path) {\n      var _a;\n      if ((0, types_1.isProgram)(path.parent) && !(0, types_1.isArrowFunctionExpression)(path.node) && !(0, types_1.isObjectMethod)(path.node) && path.node.id && path.scope.parent) {\n        const hasRecursiveCalls = ((_a = path.scope.parent.bindings[path.node.id.name]) === null || _a === void 0 ? void 0 : _a.references) > 0;\n        if (hasRecursiveCalls) {\n          path.node.body.body.unshift((0, types_1.variableDeclaration)(\"const\", [\n            (0, types_1.variableDeclarator)((0, types_1.identifier)(path.node.id.name), (0, types_1.memberExpression)((0, types_1.thisExpression)(), (0, types_1.identifier)(\"_recur\")))\n          ]));\n        }\n      }\n    }\n    function prependClosureVariablesIfNecessary(closureVariables) {\n      const closureDeclaration = (0, types_1.variableDeclaration)(\"const\", [\n        (0, types_1.variableDeclarator)((0, types_1.objectPattern)(closureVariables.map((variable) => (0, types_1.objectProperty)((0, types_1.identifier)(variable.name), (0, types_1.identifier)(variable.name), false, true))), (0, types_1.memberExpression)((0, types_1.thisExpression)(), (0, types_1.identifier)(\"__closure\")))\n      ]);\n      return {\n        visitor: {\n          \"FunctionDeclaration|FunctionExpression|ArrowFunctionExpression|ObjectMethod\": (path) => {\n            prependClosure(path, closureVariables, closureDeclaration);\n            prependRecursiveDeclaration(path);\n          }\n        }\n      };\n    }\n  }\n});\n\n// lib/globals.js\nvar require_globals = __commonJS({\n  \"lib/globals.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.initializeGlobals = exports2.globals = exports2.defaultGlobals = void 0;\n    exports2.defaultGlobals = /* @__PURE__ */ new Set([\n      \"globalThis\",\n      \"Infinity\",\n      \"NaN\",\n      \"undefined\",\n      \"eval\",\n      \"isFinite\",\n      \"isNaN\",\n      \"parseFloat\",\n      \"parseInt\",\n      \"decodeURI\",\n      \"decodeURIComponent\",\n      \"encodeURI\",\n      \"encodeURIComponent\",\n      \"escape\",\n      \"unescape\",\n      \"Object\",\n      \"Function\",\n      \"Boolean\",\n      \"Symbol\",\n      \"Error\",\n      \"AggregateError\",\n      \"EvalError\",\n      \"RangeError\",\n      \"ReferenceError\",\n      \"SyntaxError\",\n      \"TypeError\",\n      \"URIError\",\n      \"InternalError\",\n      \"Number\",\n      \"BigInt\",\n      \"Math\",\n      \"Date\",\n      \"String\",\n      \"RegExp\",\n      \"Array\",\n      \"Int8Array\",\n      \"Uint8Array\",\n      \"Uint8ClampedArray\",\n      \"Int16Array\",\n      \"Uint16Array\",\n      \"Int32Array\",\n      \"Uint32Array\",\n      \"BigInt64Array\",\n      \"BigUint64Array\",\n      \"Float32Array\",\n      \"Float64Array\",\n      \"Map\",\n      \"Set\",\n      \"WeakMap\",\n      \"WeakSet\",\n      \"ArrayBuffer\",\n      \"SharedArrayBuffer\",\n      \"DataView\",\n      \"Atomics\",\n      \"JSON\",\n      \"WeakRef\",\n      \"FinalizationRegistry\",\n      \"Iterator\",\n      \"AsyncIterator\",\n      \"Promise\",\n      \"GeneratorFunction\",\n      \"AsyncGeneratorFunction\",\n      \"Generator\",\n      \"AsyncGenerator\",\n      \"AsyncFunction\",\n      \"Reflect\",\n      \"Proxy\",\n      \"Intl\",\n      \"null\",\n      \"this\",\n      \"global\",\n      \"console\",\n      \"performance\",\n      \"queueMicrotask\",\n      \"requestAnimationFrame\",\n      \"setImmediate\",\n      \"arguments\",\n      \"HermesInternal\",\n      \"_WORKLET\",\n      \"_IS_FABRIC\",\n      \"_log\",\n      \"_toString\",\n      \"_scheduleOnJS\",\n      \"_scheduleOnRuntime\",\n      \"_makeShareableClone\",\n      \"_updateDataSynchronously\",\n      \"_getDataSynchronously\",\n      \"_updatePropsPaper\",\n      \"_updatePropsFabric\",\n      \"_removeFromPropsRegistry\",\n      \"_measurePaper\",\n      \"_measureFabric\",\n      \"_scrollToPaper\",\n      \"_dispatchCommandPaper\",\n      \"_dispatchCommandFabric\",\n      \"_setGestureState\",\n      \"_notifyAboutProgress\",\n      \"_notifyAboutEnd\",\n      \"_runOnUIQueue\",\n      \"_getAnimationTimestamp\"\n    ]);\n    function initializeGlobals() {\n      exports2.globals = new Set(exports2.defaultGlobals);\n    }\n    exports2.initializeGlobals = initializeGlobals;\n  }\n});\n\n// lib/makeWorklet.js\nvar require_makeWorklet = __commonJS({\n  \"lib/makeWorklet.js\"(exports2) {\n    \"use strict\";\n    var __importDefault = exports2 && exports2.__importDefault || function(mod) {\n      return mod && mod.__esModule ? mod : { \"default\": mod };\n    };\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.makeWorklet = void 0;\n    var core_1 = require(\"@babel/core\");\n    var generator_1 = __importDefault(require(\"@babel/generator\"));\n    var types_1 = require(\"@babel/types\");\n    var assert_1 = require(\"assert\");\n    var path_1 = require(\"path\");\n    var buildWorkletString_1 = require_buildWorkletString();\n    var globals_12 = require_globals();\n    var utils_1 = require_utils();\n    var REAL_VERSION = require(\"../../package.json\").version;\n    var MOCK_VERSION = \"x.y.z\";\n    function makeWorklet(fun, state) {\n      removeWorkletDirective(fun);\n      (0, assert_1.strict)(state.file.opts.filename, \"[Reanimated] `state.file.opts.filename` is undefined.\");\n      const codeObject = (0, generator_1.default)(fun.node, {\n        sourceMaps: true,\n        sourceFileName: state.file.opts.filename\n      });\n      codeObject.code = \"(\" + ((0, types_1.isObjectMethod)(fun) ? \"function \" : \"\") + codeObject.code + \"\\n)\";\n      const transformed = (0, core_1.transformSync)(codeObject.code, {\n        filename: state.file.opts.filename,\n        presets: [require.resolve(\"@babel/preset-typescript\")],\n        plugins: [\n          require.resolve(\"@babel/plugin-transform-shorthand-properties\"),\n          require.resolve(\"@babel/plugin-transform-arrow-functions\"),\n          require.resolve(\"@babel/plugin-proposal-optional-chaining\"),\n          require.resolve(\"@babel/plugin-proposal-nullish-coalescing-operator\"),\n          [\n            require.resolve(\"@babel/plugin-transform-template-literals\"),\n            { loose: true }\n          ]\n        ],\n        ast: true,\n        babelrc: false,\n        configFile: false,\n        inputSourceMap: codeObject.map\n      });\n      (0, assert_1.strict)(transformed, \"[Reanimated] `transformed` is undefined.\");\n      (0, assert_1.strict)(transformed.ast, \"[Reanimated] `transformed.ast` is undefined.\");\n      const variables = makeArrayFromCapturedBindings(transformed.ast, fun);\n      const functionName = makeWorkletName(fun);\n      const functionIdentifier = (0, types_1.identifier)(functionName);\n      const clone = (0, types_1.cloneNode)(fun.node);\n      const funExpression = (0, types_1.isBlockStatement)(clone.body) ? (0, types_1.functionExpression)(null, clone.params, clone.body) : clone;\n      const [funString, sourceMapString] = (0, buildWorkletString_1.buildWorkletString)(transformed.ast, variables, functionName, transformed.map);\n      (0, assert_1.strict)(funString, \"[Reanimated] `funString` is undefined.\");\n      const workletHash = hash(funString);\n      let lineOffset = 1;\n      if (variables.length > 0) {\n        lineOffset -= variables.length + 2;\n      }\n      const pathForStringDefinitions = fun.parentPath.isProgram() ? fun : fun.findParent((path) => (0, types_1.isProgram)(path.parentPath));\n      (0, assert_1.strict)(pathForStringDefinitions, \"[Reanimated] `pathForStringDefinitions` is null.\");\n      (0, assert_1.strict)(pathForStringDefinitions.parentPath, \"[Reanimated] `pathForStringDefinitions.parentPath` is null.\");\n      const initDataId = pathForStringDefinitions.parentPath.scope.generateUidIdentifier(`worklet_${workletHash}_init_data`);\n      const initDataObjectExpression = (0, types_1.objectExpression)([\n        (0, types_1.objectProperty)((0, types_1.identifier)(\"code\"), (0, types_1.stringLiteral)(funString))\n      ]);\n      const shouldInjectLocation = !(0, utils_1.isRelease)();\n      if (shouldInjectLocation) {\n        let location = state.file.opts.filename;\n        if (state.opts.relativeSourceLocation) {\n          location = (0, path_1.relative)(state.cwd, location);\n        }\n        initDataObjectExpression.properties.push((0, types_1.objectProperty)((0, types_1.identifier)(\"location\"), (0, types_1.stringLiteral)(location)));\n      }\n      if (sourceMapString) {\n        initDataObjectExpression.properties.push((0, types_1.objectProperty)((0, types_1.identifier)(\"sourceMap\"), (0, types_1.stringLiteral)(sourceMapString)));\n      }\n      const shouldInjectVersion = !(0, utils_1.isRelease)();\n      if (shouldInjectVersion) {\n        initDataObjectExpression.properties.push((0, types_1.objectProperty)((0, types_1.identifier)(\"version\"), (0, types_1.stringLiteral)(shouldMockVersion() ? MOCK_VERSION : REAL_VERSION)));\n      }\n      const shouldIncludeInitData = !state.opts.omitNativeOnlyData;\n      if (shouldIncludeInitData) {\n        pathForStringDefinitions.insertBefore((0, types_1.variableDeclaration)(\"const\", [\n          (0, types_1.variableDeclarator)(initDataId, initDataObjectExpression)\n        ]));\n      }\n      (0, assert_1.strict)(!(0, types_1.isFunctionDeclaration)(funExpression), \"[Reanimated] `funExpression` is a `FunctionDeclaration`.\");\n      (0, assert_1.strict)(!(0, types_1.isObjectMethod)(funExpression), \"[Reanimated] `funExpression` is an `ObjectMethod`.\");\n      const statements = [\n        (0, types_1.variableDeclaration)(\"const\", [\n          (0, types_1.variableDeclarator)(functionIdentifier, funExpression)\n        ]),\n        (0, types_1.expressionStatement)((0, types_1.assignmentExpression)(\"=\", (0, types_1.memberExpression)(functionIdentifier, (0, types_1.identifier)(\"__closure\"), false), (0, types_1.objectExpression)(variables.map((variable) => (0, types_1.objectProperty)((0, types_1.identifier)(variable.name), variable, false, true))))),\n        (0, types_1.expressionStatement)((0, types_1.assignmentExpression)(\"=\", (0, types_1.memberExpression)(functionIdentifier, (0, types_1.identifier)(\"__workletHash\"), false), (0, types_1.numericLiteral)(workletHash)))\n      ];\n      if (shouldIncludeInitData) {\n        statements.push((0, types_1.expressionStatement)((0, types_1.assignmentExpression)(\"=\", (0, types_1.memberExpression)(functionIdentifier, (0, types_1.identifier)(\"__initData\"), false), initDataId)));\n      }\n      if (!(0, utils_1.isRelease)()) {\n        statements.unshift((0, types_1.variableDeclaration)(\"const\", [\n          (0, types_1.variableDeclarator)((0, types_1.identifier)(\"_e\"), (0, types_1.arrayExpression)([\n            (0, types_1.newExpression)((0, types_1.memberExpression)((0, types_1.identifier)(\"global\"), (0, types_1.identifier)(\"Error\")), []),\n            (0, types_1.numericLiteral)(lineOffset),\n            (0, types_1.numericLiteral)(-27)\n          ]))\n        ]));\n        statements.push((0, types_1.expressionStatement)((0, types_1.assignmentExpression)(\"=\", (0, types_1.memberExpression)(functionIdentifier, (0, types_1.identifier)(\"__stackDetails\"), false), (0, types_1.identifier)(\"_e\"))));\n      }\n      statements.push((0, types_1.returnStatement)(functionIdentifier));\n      const newFun = (0, types_1.functionExpression)(void 0, [], (0, types_1.blockStatement)(statements));\n      return newFun;\n    }\n    exports2.makeWorklet = makeWorklet;\n    function removeWorkletDirective(fun) {\n      fun.traverse({\n        DirectiveLiteral(path) {\n          if (path.node.value === \"worklet\" && path.getFunctionParent() === fun) {\n            path.parentPath.remove();\n          }\n        }\n      });\n    }\n    function shouldMockVersion() {\n      return process.env.REANIMATED_JEST_SHOULD_MOCK_VERSION === \"1\";\n    }\n    function hash(str) {\n      let i = str.length;\n      let hash1 = 5381;\n      let hash2 = 52711;\n      while (i--) {\n        const char = str.charCodeAt(i);\n        hash1 = hash1 * 33 ^ char;\n        hash2 = hash2 * 33 ^ char;\n      }\n      return (hash1 >>> 0) * 4096 + (hash2 >>> 0);\n    }\n    function makeWorkletName(fun) {\n      if ((0, types_1.isObjectMethod)(fun.node) && (0, types_1.isIdentifier)(fun.node.key)) {\n        return fun.node.key.name;\n      }\n      if ((0, types_1.isFunctionDeclaration)(fun.node) && (0, types_1.isIdentifier)(fun.node.id)) {\n        return fun.node.id.name;\n      }\n      if ((0, types_1.isFunctionExpression)(fun.node) && (0, types_1.isIdentifier)(fun.node.id)) {\n        return fun.node.id.name;\n      }\n      return \"anonymous\";\n    }\n    function makeArrayFromCapturedBindings(ast, fun) {\n      const closure = /* @__PURE__ */ new Map();\n      const isLocationAssignedMap = /* @__PURE__ */ new Map();\n      (0, core_1.traverse)(ast, {\n        Identifier(path) {\n          if (!path.isReferencedIdentifier()) {\n            return;\n          }\n          const name = path.node.name;\n          if (globals_12.globals.has(name)) {\n            return;\n          }\n          if (\"id\" in fun.node && fun.node.id && fun.node.id.name === name) {\n            return;\n          }\n          const parentNode = path.parent;\n          if ((0, types_1.isMemberExpression)(parentNode) && parentNode.property === path.node && !parentNode.computed) {\n            return;\n          }\n          if ((0, types_1.isObjectProperty)(parentNode) && (0, types_1.isObjectExpression)(path.parentPath.parent) && path.node !== parentNode.value) {\n            return;\n          }\n          let currentScope = path.scope;\n          while (currentScope != null) {\n            if (currentScope.bindings[name] != null) {\n              return;\n            }\n            currentScope = currentScope.parent;\n          }\n          closure.set(name, path.node);\n          isLocationAssignedMap.set(name, false);\n        }\n      });\n      fun.traverse({\n        Identifier(path) {\n          if (!path.isReferencedIdentifier()) {\n            return;\n          }\n          const node = closure.get(path.node.name);\n          if (!node || isLocationAssignedMap.get(path.node.name)) {\n            return;\n          }\n          node.loc = path.node.loc;\n          isLocationAssignedMap.set(path.node.name, true);\n        }\n      });\n      return Array.from(closure.values());\n    }\n  }\n});\n\n// lib/processWorkletObjectMethod.js\nvar require_processWorkletObjectMethod = __commonJS({\n  \"lib/processWorkletObjectMethod.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.processWorkletObjectMethod = void 0;\n    var types_1 = require(\"@babel/types\");\n    var makeWorklet_1 = require_makeWorklet();\n    function processWorkletObjectMethod(path, state) {\n      if (!(0, types_1.isFunctionParent)(path)) {\n        return;\n      }\n      const newFun = (0, makeWorklet_1.makeWorklet)(path, state);\n      const replacement = (0, types_1.objectProperty)((0, types_1.identifier)((0, types_1.isIdentifier)(path.node.key) ? path.node.key.name : \"\"), (0, types_1.callExpression)(newFun, []));\n      path.replaceWith(replacement);\n    }\n    exports2.processWorkletObjectMethod = processWorkletObjectMethod;\n  }\n});\n\n// lib/processIfWorkletFunction.js\nvar require_processIfWorkletFunction = __commonJS({\n  \"lib/processIfWorkletFunction.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.processIfWorkletFunction = void 0;\n    var types_1 = require(\"@babel/types\");\n    var makeWorklet_1 = require_makeWorklet();\n    function processIfWorkletFunction(path, state) {\n      if (path.isFunctionDeclaration() || path.isFunctionExpression() || path.isArrowFunctionExpression()) {\n        processWorkletFunction(path, state);\n      }\n    }\n    exports2.processIfWorkletFunction = processIfWorkletFunction;\n    function processWorkletFunction(path, state) {\n      const workletFactory = (0, makeWorklet_1.makeWorklet)(path, state);\n      const workletFactoryCall = (0, types_1.callExpression)(workletFactory, []);\n      const originalWorkletLocation = path.node.loc;\n      if (originalWorkletLocation) {\n        workletFactoryCall.callee.loc = {\n          start: originalWorkletLocation.start,\n          end: originalWorkletLocation.start\n        };\n      }\n      const needDeclaration = (0, types_1.isScopable)(path.parent) || (0, types_1.isExportNamedDeclaration)(path.parent);\n      const replacement = \"id\" in path.node && path.node.id && needDeclaration ? (0, types_1.variableDeclaration)(\"const\", [\n        (0, types_1.variableDeclarator)(path.node.id, workletFactoryCall)\n      ]) : workletFactoryCall;\n      path.replaceWith(replacement);\n    }\n  }\n});\n\n// lib/processForCalleesWorklets.js\nvar require_processForCalleesWorklets = __commonJS({\n  \"lib/processForCalleesWorklets.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.processForCalleesWorklets = void 0;\n    var types_1 = require(\"@babel/types\");\n    var processWorkletObjectMethod_1 = require_processWorkletObjectMethod();\n    var processIfWorkletFunction_1 = require_processIfWorkletFunction();\n    var assert_1 = require(\"assert\");\n    var functionArgsToWorkletize = /* @__PURE__ */ new Map([\n      [\"useFrameCallback\", [0]],\n      [\"useAnimatedStyle\", [0]],\n      [\"useAnimatedProps\", [0]],\n      [\"createAnimatedPropAdapter\", [0]],\n      [\"useDerivedValue\", [0]],\n      [\"useAnimatedScrollHandler\", [0]],\n      [\"useAnimatedReaction\", [0, 1]],\n      [\"useWorkletCallback\", [0]],\n      [\"withTiming\", [2]],\n      [\"withSpring\", [2]],\n      [\"withDecay\", [1]],\n      [\"withRepeat\", [3]],\n      [\"runOnUI\", [0]]\n    ]);\n    var objectHooks = /* @__PURE__ */ new Set([\n      \"useAnimatedGestureHandler\",\n      \"useAnimatedScrollHandler\"\n    ]);\n    function processForCalleesWorklets(path, state) {\n      const callee = (0, types_1.isSequenceExpression)(path.node.callee) ? path.node.callee.expressions[path.node.callee.expressions.length - 1] : path.node.callee;\n      const name = \"name\" in callee ? callee.name : \"property\" in callee && \"name\" in callee.property ? callee.property.name : void 0;\n      if (name === void 0) {\n        return;\n      }\n      if (objectHooks.has(name)) {\n        const workletToProcess = path.get(\"arguments.0\");\n        (0, assert_1.strict)(!Array.isArray(workletToProcess), \"[Reanimated] `workletToProcess` is an array.\");\n        if (workletToProcess.isObjectExpression()) {\n          processObjectHook(workletToProcess, state);\n        } else if (name === \"useAnimatedScrollHandler\") {\n          (0, processIfWorkletFunction_1.processIfWorkletFunction)(workletToProcess, state);\n        }\n      } else {\n        const indices = functionArgsToWorkletize.get(name);\n        if (indices === void 0) {\n          return;\n        }\n        processArguments(path, indices, state);\n      }\n    }\n    exports2.processForCalleesWorklets = processForCalleesWorklets;\n    function processObjectHook(path, state) {\n      const properties = path.get(\"properties\");\n      for (const property of properties) {\n        if (property.isObjectMethod()) {\n          (0, processWorkletObjectMethod_1.processWorkletObjectMethod)(property, state);\n        } else if (property.isObjectProperty()) {\n          const value = property.get(\"value\");\n          (0, processIfWorkletFunction_1.processIfWorkletFunction)(value, state);\n        } else {\n          throw new Error(`[Reanimated] '${property.type}' as to-be workletized arguments is not supported for object hooks.`);\n        }\n      }\n    }\n    function processArguments(path, indices, state) {\n      const argumentsArray = path.get(\"arguments\");\n      indices.forEach((index) => {\n        const argumentToWorkletize = argumentsArray[index];\n        if (!argumentToWorkletize) {\n          return;\n        }\n        (0, processIfWorkletFunction_1.processIfWorkletFunction)(argumentToWorkletize, state);\n      });\n    }\n  }\n});\n\n// lib/processIfWorkletNode.js\nvar require_processIfWorkletNode = __commonJS({\n  \"lib/processIfWorkletNode.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.processIfWorkletNode = void 0;\n    var types_1 = require(\"@babel/types\");\n    var processIfWorkletFunction_1 = require_processIfWorkletFunction();\n    function hasWorkletDirective(directives) {\n      return directives && directives.length > 0 && directives.some((directive) => (0, types_1.isDirectiveLiteral)(directive.value) && directive.value.value === \"worklet\");\n    }\n    function processIfWorkletNode(fun, state) {\n      let shouldBeProcessed = false;\n      fun.traverse({\n        DirectiveLiteral(path) {\n          const value = path.node.value;\n          if (value === \"worklet\" && (0, types_1.isBlockStatement)(fun.node.body)) {\n            const parent = path.getFunctionParent();\n            if (parent === fun) {\n              const directives = fun.node.body.directives;\n              shouldBeProcessed = hasWorkletDirective(directives);\n            } else if (state.opts.processNestedWorklets && ((parent === null || parent === void 0 ? void 0 : parent.isFunctionDeclaration()) || (parent === null || parent === void 0 ? void 0 : parent.isFunctionExpression()) || (parent === null || parent === void 0 ? void 0 : parent.isArrowFunctionExpression()))) {\n              processIfWorkletNode(parent, state);\n            }\n          }\n        }\n      });\n      if (shouldBeProcessed) {\n        (0, processIfWorkletFunction_1.processIfWorkletFunction)(fun, state);\n      }\n    }\n    exports2.processIfWorkletNode = processIfWorkletNode;\n  }\n});\n\n// lib/processInlineStylesWarning.js\nvar require_processInlineStylesWarning = __commonJS({\n  \"lib/processInlineStylesWarning.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.processInlineStylesWarning = void 0;\n    var types_1 = require(\"@babel/types\");\n    var utils_1 = require_utils();\n    var assert_1 = require(\"assert\");\n    function generateInlineStylesWarning(path) {\n      return (0, types_1.callExpression)((0, types_1.arrowFunctionExpression)([], (0, types_1.blockStatement)([\n        (0, types_1.expressionStatement)((0, types_1.callExpression)((0, types_1.memberExpression)((0, types_1.identifier)(\"console\"), (0, types_1.identifier)(\"warn\")), [\n          (0, types_1.callExpression)((0, types_1.memberExpression)((0, types_1.callExpression)((0, types_1.identifier)(\"require\"), [\n            (0, types_1.stringLiteral)(\"react-native-reanimated\")\n          ]), (0, types_1.identifier)(\"getUseOfValueInStyleWarning\")), [])\n        ])),\n        (0, types_1.returnStatement)(path.node)\n      ])), []);\n    }\n    function processPropertyValueForInlineStylesWarning(path) {\n      if (path.isMemberExpression() && (0, types_1.isIdentifier)(path.node.property)) {\n        if (path.node.property.name === \"value\") {\n          path.replaceWith(generateInlineStylesWarning(path));\n        }\n      }\n    }\n    function processTransformPropertyForInlineStylesWarning(path) {\n      if ((0, types_1.isArrayExpression)(path.node)) {\n        const elements = path.get(\"elements\");\n        (0, assert_1.strict)(Array.isArray(elements), \"[Reanimated] `elements` should be an array.\");\n        for (const element of elements) {\n          if (element.isObjectExpression()) {\n            processStyleObjectForInlineStylesWarning(element);\n          }\n        }\n      }\n    }\n    function processStyleObjectForInlineStylesWarning(path) {\n      const properties = path.get(\"properties\");\n      for (const property of properties) {\n        if (property.isObjectProperty()) {\n          const value = property.get(\"value\");\n          if ((0, types_1.isIdentifier)(property.node.key) && property.node.key.name === \"transform\") {\n            processTransformPropertyForInlineStylesWarning(value);\n          } else {\n            processPropertyValueForInlineStylesWarning(value);\n          }\n        }\n      }\n    }\n    function processInlineStylesWarning(path, state) {\n      if ((0, utils_1.isRelease)()) {\n        return;\n      }\n      if (state.opts.disableInlineStylesWarning) {\n        return;\n      }\n      if (path.node.name.name !== \"style\") {\n        return;\n      }\n      if (!(0, types_1.isJSXExpressionContainer)(path.node.value)) {\n        return;\n      }\n      const expression = path.get(\"value\").get(\"expression\");\n      (0, assert_1.strict)(!Array.isArray(expression), \"[Reanimated] `expression` should not be an array.\");\n      if (expression.isArrayExpression()) {\n        const elements = expression.get(\"elements\");\n        (0, assert_1.strict)(Array.isArray(elements), \"[Reanimated] `elements` should be an array.\");\n        for (const element of elements) {\n          if (element.isObjectExpression()) {\n            processStyleObjectForInlineStylesWarning(element);\n          }\n        }\n      } else if (expression.isObjectExpression()) {\n        processStyleObjectForInlineStylesWarning(expression);\n      }\n    }\n    exports2.processInlineStylesWarning = processInlineStylesWarning;\n  }\n});\n\n// lib/isGestureHandlerEventCallback.js\nvar require_isGestureHandlerEventCallback = __commonJS({\n  \"lib/isGestureHandlerEventCallback.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.isGestureHandlerEventCallback = void 0;\n    var types_1 = require(\"@babel/types\");\n    var gestureHandlerGestureObjects = /* @__PURE__ */ new Set([\n      \"Tap\",\n      \"Pan\",\n      \"Pinch\",\n      \"Rotation\",\n      \"Fling\",\n      \"LongPress\",\n      \"ForceTouch\",\n      \"Native\",\n      \"Manual\",\n      \"Race\",\n      \"Simultaneous\",\n      \"Exclusive\",\n      \"Hover\"\n    ]);\n    var gestureHandlerBuilderMethods = /* @__PURE__ */ new Set([\n      \"onBegin\",\n      \"onStart\",\n      \"onEnd\",\n      \"onFinalize\",\n      \"onUpdate\",\n      \"onChange\",\n      \"onTouchesDown\",\n      \"onTouchesMove\",\n      \"onTouchesUp\",\n      \"onTouchesCancelled\"\n    ]);\n    function isGestureHandlerEventCallback(path) {\n      return (0, types_1.isCallExpression)(path.parent) && (0, types_1.isExpression)(path.parent.callee) && isGestureObjectEventCallbackMethod(path.parent.callee);\n    }\n    exports2.isGestureHandlerEventCallback = isGestureHandlerEventCallback;\n    function isGestureObjectEventCallbackMethod(exp) {\n      return (0, types_1.isMemberExpression)(exp) && (0, types_1.isIdentifier)(exp.property) && gestureHandlerBuilderMethods.has(exp.property.name) && containsGestureObject(exp.object);\n    }\n    function containsGestureObject(exp) {\n      if (isGestureObject(exp)) {\n        return true;\n      }\n      if ((0, types_1.isCallExpression)(exp) && (0, types_1.isMemberExpression)(exp.callee) && containsGestureObject(exp.callee.object)) {\n        return true;\n      }\n      return false;\n    }\n    function isGestureObject(exp) {\n      return (0, types_1.isCallExpression)(exp) && (0, types_1.isMemberExpression)(exp.callee) && (0, types_1.isIdentifier)(exp.callee.object) && exp.callee.object.name === \"Gesture\" && (0, types_1.isIdentifier)(exp.callee.property) && gestureHandlerGestureObjects.has(exp.callee.property.name);\n    }\n  }\n});\n\n// lib/isLayoutAnimationCallback.js\nvar require_isLayoutAnimationCallback = __commonJS({\n  \"lib/isLayoutAnimationCallback.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.isLayoutAnimationCallback = void 0;\n    var types_1 = require(\"@babel/types\");\n    var EntryExitAnimations = /* @__PURE__ */ new Set([\n      \"BounceIn\",\n      \"BounceInDown\",\n      \"BounceInLeft\",\n      \"BounceInRight\",\n      \"BounceInUp\",\n      \"BounceOut\",\n      \"BounceOutDown\",\n      \"BounceOutLeft\",\n      \"BounceOutRight\",\n      \"BounceOutUp\",\n      \"FadeIn\",\n      \"FadeInDown\",\n      \"FadeInLeft\",\n      \"FadeInRight\",\n      \"FadeInUp\",\n      \"FadeOut\",\n      \"FadeOutDown\",\n      \"FadeOutLeft\",\n      \"FadeOutRight\",\n      \"FadeOutUp\",\n      \"FlipInEasyX\",\n      \"FlipInEasyY\",\n      \"FlipInXDown\",\n      \"FlipInXUp\",\n      \"FlipInYLeft\",\n      \"FlipInYRight\",\n      \"FlipOutEasyX\",\n      \"FlipOutEasyY\",\n      \"FlipOutXDown\",\n      \"FlipOutXUp\",\n      \"FlipOutYLeft\",\n      \"FlipOutYRight\",\n      \"LightSpeedInLeft\",\n      \"LightSpeedInRight\",\n      \"LightSpeedOutLeft\",\n      \"LightSpeedOutRight\",\n      \"PinwheelIn\",\n      \"PinwheelOut\",\n      \"RollInLeft\",\n      \"RollInRight\",\n      \"RollOutLeft\",\n      \"RollOutRight\",\n      \"RotateInDownLeft\",\n      \"RotateInDownRight\",\n      \"RotateInUpLeft\",\n      \"RotateInUpRight\",\n      \"RotateOutDownLeft\",\n      \"RotateOutDownRight\",\n      \"RotateOutUpLeft\",\n      \"RotateOutUpRight\",\n      \"SlideInDown\",\n      \"SlideInLeft\",\n      \"SlideInRight\",\n      \"SlideInUp\",\n      \"SlideOutDown\",\n      \"SlideOutLeft\",\n      \"SlideOutRight\",\n      \"SlideOutUp\",\n      \"StretchInX\",\n      \"StretchInY\",\n      \"StretchOutX\",\n      \"StretchOutY\",\n      \"ZoomIn\",\n      \"ZoomInDown\",\n      \"ZoomInEasyDown\",\n      \"ZoomInEasyUp\",\n      \"ZoomInLeft\",\n      \"ZoomInRight\",\n      \"ZoomInRotate\",\n      \"ZoomInUp\",\n      \"ZoomOut\",\n      \"ZoomOutDown\",\n      \"ZoomOutEasyDown\",\n      \"ZoomOutEasyUp\",\n      \"ZoomOutLeft\",\n      \"ZoomOutRight\",\n      \"ZoomOutRotate\",\n      \"ZoomOutUp\"\n    ]);\n    var LayoutTransitions = /* @__PURE__ */ new Set([\n      \"Layout\",\n      \"LinearTransition\",\n      \"SequencedTransition\",\n      \"FadingTransition\",\n      \"JumpingTransition\",\n      \"CurvedTransition\",\n      \"EntryExitTransition\"\n    ]);\n    var LayoutAnimations = /* @__PURE__ */ new Set([\n      ...EntryExitAnimations,\n      ...LayoutTransitions\n    ]);\n    var BaseAnimationsChainableMethods = /* @__PURE__ */ new Set([\n      \"build\",\n      \"duration\",\n      \"delay\",\n      \"getDuration\",\n      \"randomDelay\",\n      \"getDelay\",\n      \"getDelayFunction\"\n    ]);\n    var ComplexAnimationsChainableMethods = /* @__PURE__ */ new Set([\n      \"easing\",\n      \"rotate\",\n      \"springify\",\n      \"damping\",\n      \"mass\",\n      \"stiffness\",\n      \"overshootClamping\",\n      \"restDisplacementThreshold\",\n      \"restSpeedThreshold\",\n      \"withInitialValues\",\n      \"getAnimationAndConfig\"\n    ]);\n    var DefaultTransitionChainableMethods = /* @__PURE__ */ new Set([\n      \"easingX\",\n      \"easingY\",\n      \"easingWidth\",\n      \"easingHeight\",\n      \"entering\",\n      \"exiting\",\n      \"reverse\"\n    ]);\n    var LayoutAnimationsChainableMethods = /* @__PURE__ */ new Set([\n      ...BaseAnimationsChainableMethods,\n      ...ComplexAnimationsChainableMethods,\n      ...DefaultTransitionChainableMethods\n    ]);\n    var LayoutAnimationsCallbacks = /* @__PURE__ */ new Set([\"withCallback\"]);\n    function isLayoutAnimationCallback(path) {\n      return (0, types_1.isCallExpression)(path.parent) && (0, types_1.isExpression)(path.parent.callee) && isLayoutAnimationCallbackMethod(path.parent.callee);\n    }\n    exports2.isLayoutAnimationCallback = isLayoutAnimationCallback;\n    function isLayoutAnimationCallbackMethod(exp) {\n      return (0, types_1.isMemberExpression)(exp) && (0, types_1.isIdentifier)(exp.property) && LayoutAnimationsCallbacks.has(exp.property.name) && isLayoutAnimationsChainableOrNewOperator(exp.object);\n    }\n    function isLayoutAnimationsChainableOrNewOperator(exp) {\n      if ((0, types_1.isIdentifier)(exp) && LayoutAnimations.has(exp.name)) {\n        return true;\n      } else if ((0, types_1.isNewExpression)(exp) && (0, types_1.isIdentifier)(exp.callee) && LayoutAnimations.has(exp.callee.name)) {\n        return true;\n      }\n      if ((0, types_1.isCallExpression)(exp) && (0, types_1.isMemberExpression)(exp.callee) && (0, types_1.isIdentifier)(exp.callee.property) && LayoutAnimationsChainableMethods.has(exp.callee.property.name) && isLayoutAnimationsChainableOrNewOperator(exp.callee.object)) {\n        return true;\n      }\n      return false;\n    }\n  }\n});\n\n// lib/processIfCallback.js\nvar require_processIfCallback = __commonJS({\n  \"lib/processIfCallback.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.processIfCallback = void 0;\n    var isGestureHandlerEventCallback_1 = require_isGestureHandlerEventCallback();\n    var processIfWorkletFunction_1 = require_processIfWorkletFunction();\n    var isLayoutAnimationCallback_1 = require_isLayoutAnimationCallback();\n    function processIfCallback(path, state) {\n      if ((0, isGestureHandlerEventCallback_1.isGestureHandlerEventCallback)(path) || (0, isLayoutAnimationCallback_1.isLayoutAnimationCallback)(path)) {\n        (0, processIfWorkletFunction_1.processIfWorkletFunction)(path, state);\n      }\n    }\n    exports2.processIfCallback = processIfCallback;\n  }\n});\n\n// lib/addCustomGlobals.js\nvar require_addCustomGlobals = __commonJS({\n  \"lib/addCustomGlobals.js\"(exports2) {\n    \"use strict\";\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n    exports2.addCustomGlobals = void 0;\n    var globals_12 = require_globals();\n    function addCustomGlobals() {\n      if (this.opts && Array.isArray(this.opts.globals)) {\n        this.opts.globals.forEach((name) => {\n          globals_12.globals.add(name);\n        });\n      }\n    }\n    exports2.addCustomGlobals = addCustomGlobals;\n  }\n});\n\n// lib/plugin.js\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar processForCalleesWorklets_1 = require_processForCalleesWorklets();\nvar processIfWorkletNode_1 = require_processIfWorkletNode();\nvar processInlineStylesWarning_1 = require_processInlineStylesWarning();\nvar processIfCallback_1 = require_processIfCallback();\nvar addCustomGlobals_1 = require_addCustomGlobals();\nvar globals_1 = require_globals();\nmodule.exports = function() {\n  function runWithTaggedExceptions(fun) {\n    try {\n      fun();\n    } catch (e) {\n      throw new Error(\"[Reanimated] Babel plugin exception: \" + e);\n    }\n  }\n  return {\n    pre() {\n      runWithTaggedExceptions(() => {\n        (0, globals_1.initializeGlobals)();\n        addCustomGlobals_1.addCustomGlobals.call(this);\n      });\n    },\n    visitor: {\n      CallExpression: {\n        enter(path, state) {\n          runWithTaggedExceptions(() => (0, processForCalleesWorklets_1.processForCalleesWorklets)(path, state));\n        }\n      },\n      \"FunctionDeclaration|FunctionExpression|ArrowFunctionExpression\": {\n        enter(path, state) {\n          runWithTaggedExceptions(() => {\n            (0, processIfWorkletNode_1.processIfWorkletNode)(path, state);\n            (0, processIfCallback_1.processIfCallback)(path, state);\n          });\n        }\n      },\n      JSXAttribute: {\n        enter(path, state) {\n          runWithTaggedExceptions(() => (0, processInlineStylesWarning_1.processInlineStylesWarning)(path, state));\n        }\n      }\n    }\n  };\n};\n//# sourceMappingURL=plugin.js.map\n"
))
